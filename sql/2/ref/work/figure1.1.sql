# function multiply(x,y)
# Input: Two n-bit integers x and y, where y>= 0
# Output: Their product

if y=0: return 0
z = multiply(x,abs(y/2))
if y is even:
  return 2z
else:
  return x + 2z


#

1.1. symbolic

x * y = {

  y == even: 2(x* abs(y/2))
  y == odd:  x + 2(x * abs(y/2))

#

1.1 explicit, python

recursive to 1000

#

ch 2 substantially better:

bc + ad = (a + b) * (c + d) - (a * c) - (b * d)

# ^ gauss, 1777-1855

T(n) <= 3T(n/2 + 1) + Big-O(n)

# ^ Figure 2.1

function multiply(x,y)
# Input: as prior
# Output: as Prior

n = max(size x, size y)
if n == 1: return x * y

xL, xR = leftmost abs(n/2), rightmost abs(n/2) bits of x
yL, yR = leftmost abs(n/2), rightmost abs(n/2) bits of y

P1 = multiply(xL, yL)
P2 = multiply(xR, yR)
P3 = multiply((xL + xR), (yL + yR))

return P 1 x 2^n + (P3 - P1 - P2) x 2^(n/2) + P2

## Sum of any increasing geometric series is, within a constant factor,
#  simply the last term of the series (Vazirani, Exercise 0.2)
#

This implemented herein (project for the day).


